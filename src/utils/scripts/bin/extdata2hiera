#!/usr/bin/env ruby

require 'optparse'
require 'csv'

options = {:in => nil, :out => nil, :format => :yaml}

OptionParser.new do |opts|
  opts.banner = "Converter for extlookup CSV files into Hiera JSON and YAML files"

  opts.on("--in FILE", "-i", "Input CSV file") do |v|
    options[:in] = v
  end

  opts.on("--out FILE", "-o", "Output Hiera file") do |v|
    options[:out] = v
  end

  opts.on("--json", "-j", "Create JSON format file") do |v|
    options[:format] = :json
  end
end.parse!

if options[:in].nil? || options[:out].nil?
  STDERR.puts "Please specify an input and output file with --in and --out"
  exit 1
end

unless File.exist?(options[:in])
  STDERR.puts "Cannot find input file #{options[:in]}"
  exit 1
end

csvdata = CSV.read(options[:in])
hieradata = {}

csvdata.each do |d|
  d = d.map{|item| item.to_s}

  if d.size > 2
    hieradata[d[0]] = d[1, d.size].flatten
  else
    hieradata[d[0]] = d[1]
  end
end

case options[:format]
when :yaml
  require 'yaml'
  fh = File.open(options[:out], "w")

  fh.puts('---')

  content = []
  File.read(options[:in]).each_line do |line|
    next if line =~ /^\s*$/

    if line =~ /^\s*#/ then
      content << "#{line.strip}"
      next
    end

    ln = CSV.parse(line).flatten

    newln = "#{ln.shift}: "
    ln.map!{|x|
      if not ['true','false'].include?(x) then
        x = "\"#{x}\""
      else
        x = x
      end
    }

    if ln.size == 1 then
      newln += "#{ln.shift}"
    else
       newln += "\n" + ln.map{|x| x = "    - #{x}"}.join("\n")
    end
    content << newln
  end

  fh.puts(content.join("\n"))

  fh.close
when :json
  require 'rubygems'
  require 'json'
  fh = File.open(options[:out], "w")

  fh.puts('{')

  content = []
  commentnum = 0

  File.read(options[:in]).each_line do |line|
    next if line =~ /^\s*$/

    if line =~ /^\s*#/ then
      content << "  \"_c#{commentnum}\": \"#{line.strip}\""
      commentnum += 1
      next
    end

    ln = CSV.parse(line).flatten

    newln = "  \"#{ln.shift}\": "
    ln.map!{|x|
      if not ['true','false'].include?(x) then
        x = "\"#{x}\""
      else
        x = x
      end
    }

    if ln.size == 1 then
      newln += "#{ln.shift}"
    else
       newln += "  [\n"
       newln += "    #{ln.join(",\n    ")}"
       newln += "\n  ]"
    end
    content << newln
  end

  fh.puts(content.join(",\n"))
  fh.puts('}')

  fh.close
end
