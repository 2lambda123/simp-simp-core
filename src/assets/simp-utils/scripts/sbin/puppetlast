#!/opt/puppetlabs/puppet/bin/ruby
#
# puppetlast queries PuppetDB and returns a list of nodes and the last time the
# Puppet Agent was run on them

require "uri"
require 'date'
require 'puppet'
require 'facter'
require 'ostruct'
require 'optparse'
require "net/http"

class PuppetLast
  def parse_options(args)
    @options = OpenStruct.new
    @options.expiration = 5
    @options.outtime = ''
    @options.hosts = []
    @options.pretty = false
    @options.sort_by = :certname
    # This currently isn't settable...
    @options.round_to = '.02'

    opts = OptionParser.new do |opts|
      opts.banner = "Usage: #{File.basename(__FILE__)} [options]"

      opts.separator ""

      opts.on(
        "-e",
        "--expiration NUM",
        Float,
         "Don't show systems that have not checked in for more than NUM days."
      ) do |exp|
        if exp == 0 then
          @options.expiration = 99999
        else
          @options.expiration = exp.to_f.abs
        end
      end

      opts.on(
        "-t",
        "--timeformat TF",
        [:seconds, :minutes, :hours, :days],
        "Select output time format (seconds, minutes, hours, days)"
      ) do |tf|
        @options.outtime = tf
      end

      opts.on(
        "--hosts a,b,c",
        Array,
        "List of hosts (short or long) that you wish to get data on"
      ) do |hosts|
        @options.hosts = hosts
      end

      opts.on(
        "-p",
        "--pretty",
        "Format the output more attractively."
      ) do |pretty|
        @options.pretty = pretty
      end

      opts.on(
        "-s",
        "--sort-by SORT_OPTION",
        [:nil, :certname, :time],
        "Sort by a given attribute: 'nil' => unsorted, 'certname' => default, 'time' => last checkin"
      ) do |sort_by|
        @options.sort_by = sort_by
      end

      opts.on(
        "-h",
        "--help",
        "Help Message"
      ) do
        puts opts
        @options.help_requested = true
      end
    end

    begin
      opts.parse!(args)
    rescue OptionParser::ParseError => e
      raise "ERROR #{e.message}\n#{opts.to_s}"
    end

    case @options.outtime.to_s
      when /^s.*/ then
        @options.outtime = 'seconds'
        @options.divisor = 1
      when /^h.*/ then
        @options.outtime = 'hours'
        @options.divisor = 1/Float(3600)
      when /^d.*/ then
        @options.outtime = 'days'
        @options.divisor = 1/Float(86400)
      else
        @options.outtime = 'minutes'
        @options.divisor = 1/Float(60)
    end

    @options.expsecs = @options.expiration * 86400
  end

  # grabs info about a particular host from PuppetDB
  def query_host(certname)
    # TODO move to ssl
    uri = URI("http://localhost:8138/pdb/query/v4/nodes/#{certname}")

    begin
      data = JSON.parse(Net::HTTP.get(uri), :symbolize_names => true)
    rescue Errno::ECONNREFUSED => e
      err_msg = "ERROR: #{e}" +
                "  Please make sure PuppetDB is running, this script is being run from" +
                "  the PuppetDB host, and the port is correct"
      raise err_msg
    end

    if data.keys.include? :error then
      err_msg = "ERROR: Could not retrieve node data for #{certname}" +
                "  Server Said: #{data}"
      raise err_msg
    end

    data
  end

  # grabs info about all hosts in PuppetDB
  def query_hosts
    # TODO move to ssl
    uri = URI('http://localhost:8138/pdb/query/v4/nodes')

    begin
      data = JSON.parse(Net::HTTP.get(uri), :symbolize_names => true)
    rescue Errno::ECONNREFUSED => e
      err_msg = "ERROR: #{e}" +
                "  Please make sure PuppetDB is running, this script is being run from" +
                "  the PuppetDB host, and the port is correct"
      raise err_msg
    end

    data
  end

  # take the PuppetDB scehema and transform it into useful info for us
  def transform_hosts(hosts)
    node_data = []

    hosts.each do |host|
      last_checkin = Time.now - Time.parse(host[:catalog_timestamp])
      node_data << {
        :expired      => host[:expired],
        :certname     => host[:certname],
        :last_checkin => last_checkin,
        :formatted_checkin => sprintf("%#{@options.round_to}f",(last_checkin * @options.divisor).abs),
      }
    end

    node_data
  end


  def main(args)
    parse_options(args)
    return 0 if @options.help_requested

    if @options.hosts.empty? then
      hostlist = query_hosts
    else
      hostlist = []
      @options.hosts.each do |host|
        hostlist << query_host(host)
      end
    end

    node_data = transform_hosts(hostlist)

    if @options.sort_by == :certname then
      node_data = node_data.sort{ |a,b| a[:certname] <=> b[:certname] }
    elsif @options.sort_by == :time then
      node_data = node_data.sort{ |a,b| a[:last_checkin] <=> b[:last_checkin] }
    end

    first_column_length = 0
    time_column_length = 0
    if @options.pretty then
      first_column_length = node_data.select{|x|
          !x[:expired]
        }.max {|a,b|
          a[:certname].length <=> b[:certname].length
        }[:certname].length

      time_column_length = node_data.select{|x|
          !x[:expired]
        }.max {|a,b|
          a[:formatted_checkin].length <=> b[:formatted_checkin].length
        }[:formatted_checkin].length

    end

    node_data.each do |node|
      if not node[:expired] then
        if ( node[:last_checkin] < 0 ) then
          msg = "-#{first_column_length}s time issue: %#{time_column_length}#{@options.round_to}f %s in the future\n"
        elsif ( node[:last_checkin] < @options.expsecs ) then
          msg = "%-#{first_column_length}s checked in %#{time_column_length}#{@options.round_to}f %s ago\n"
        end

        if node[:last_checkin].to_s =~ /e/ then
          puts "#{node[:certname]} outside the bounds of time and space"
        else
          printf(msg,
            node[:certname],
            node[:formatted_checkin],
            @options.outtime
          )
        end
      else
        puts "#{node[:certname]} expired" if @options.verbose
      end
    end
    return 0
  rescue SignalException =>e
    if e.inspect == 'Interrupt'
      $stderr.puts "\nProcessing interrupted! Exiting."
    else
      $stderr.puts "\nProcess received signal #{e.message}. Exiting!"
      e.backtrace.first(10).each{|l| $stderr.puts l }
    end
    return 1
  rescue RuntimeError =>e
    $stderr.puts(e.message)
    return 1
  rescue => e
    $stderr.puts("\n#{e.message}")
    e.backtrace.first(10).each{|l| $stderr.puts l }
    return 1
  end

end

if __FILE__ == $0
  pl = PuppetLast.new
  exit pl.main(ARGV)
end
